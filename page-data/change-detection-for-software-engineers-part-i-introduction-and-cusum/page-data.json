{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/change-detection-for-software-engineers-part-i-introduction-and-cusum","result":{"data":{"post":{"__typename":"MdxPost","slug":"/change-detection-for-software-engineers-part-i-introduction-and-cusum","title":"Change Detection for Software Engineers Part I : Introduction and CUSUM","date":"03.10.2017","tags":[{"name":"java","slug":"java"},{"name":"data-science","slug":"data-science"},{"name":"statistics","slug":"statistics"},{"name":"cd","slug":"cd"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Change Detection for Software Engineers Part I : Introduction and CUSUM\",\n  \"date\": \"2017-10-03T00:00:00.000Z\",\n  \"slug\": \"/change-detection-for-software-engineers-part-i-introduction-and-cusum\",\n  \"tags\": [\"java\", \"data-science\", \"statistics\", \"cd\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I've decided to force myself into the habit of blogging about my PhD topic, in the hope that people who find these posts have an easier time comprehending the subject matter than I did. This, and future posts, will attempt to focus on a particular method at a time. I will present the maths for reference, but generally speaking the explanations will use as little maths as possible. My hope is that this will be at a digestible level for software engineers who have a practical interest in these techniques.\"), mdx(\"p\", null, \"What is the topic? Change Detection, specifically in streaming data. If that sounds like a pretty broad area to you, then you're absolutely right. We have a little bit of ground to cover first to explain what I mean by Change Detection and how it relates to other similar things we could do. \"), mdx(\"h5\", null, \"Background\"), mdx(\"p\", null, \"I will assume that you have some data that you collect incrementally. Let's say you record the time taken to process every request in your web application. You'd like to be alerted if there's a significant change in the average time taken to process a request - increases may indicate a DDoS, decreases may mean an error is causing requests to bail out prematurely.\"), mdx(\"p\", null, \"What you have here is a data stream. We can write that like so:\"), mdx(\"p\", null, \"$$\\nX = \\\\left \", \"\\\\\", \"{ \\\\vec{x}\", \"_\", \"1, \\\\vec{x}\", \"_\", \"2, ... \\\\right \", \"\\\\\", \"}\\n$$\"), mdx(\"p\", null, \"So, $ \\\\vec{x}\", \"_\", \"t $ is a piece of data arriving at time $t$. The little arrow above the $x$ means that this is a vector, i.e. the piece of data could have one or more elements.\"), mdx(\"p\", null, \"Anyway, we collect the request times for our web app. At midnight, a group of Russian hackers decide to pwn you with a botnet. Request completion times start to increase. Clearly this will be reflected in the data we collect. We will have what is called a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Change Point\"), \" at 12:00.\"), mdx(\"p\", null, \"How do we define a change point? The data we are observing is changing in response to something. This purely conceptual \\\"something\\\" is what we call a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Data Source\"), \" (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Class\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Concept\"), \"). We say that before the event is one data source $S\", \"_\", \"1$, and after the event is another, $S\", \"_\", \"2$. Therefore, a change point is where there is a switch from one data source to another. Our change point at time $t$ is denoted by:\"), mdx(\"p\", null, \"$$\\\\left \", \"\\\\\", \"{ ..., \\\\vec{x}\", \"_\", \"{t-2}, \\\\vec{x}\", \"_\", \"{t-1} \\\\right \", \"\\\\\", \"} \\\\in S_1$$\"), mdx(\"p\", null, \"$$\\\\left \", \"\\\\\", \"{ \\\\vec{x}\", \"_\", \"{t}, \\\\vec{x}\", \"_\", \"{t+1}, ... \\\\right \", \"\\\\\", \"} \\\\in S_2$$\"), mdx(\"p\", null, \"($\\\\in$ \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"is used here to mean 'is drawn from'\"), \") \"), mdx(\"p\", null, \"Change Detection then, is to detect that $S\", \"_\", \"1$ has changed to $S\", \"_\", \"2$ as soon as possible after $t$. We don't know what's caused the change, and we don't know what that change will look like in the data. This isn't a classification problem, and we don't have any prior knowledge, heuristics or training data to help us.\"), mdx(\"p\", null, \"If you decide to read around this subject, you'll quickly become confused about what the boundary is between this and\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Anomaly Detection\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Novelty Detection\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Outlier Detection\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Change Point Detection\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Concept Drift Detection\")), mdx(\"p\", null, \"That's a story for another blog post. Just know that Change Detection \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"is\"), \" subtly different, and the methods we use are often cross-applicable. These each refer to a very similar problem with slightly tweaked context.\"), mdx(\"h5\", null, \"CUSUM\"), mdx(\"p\", null, \"Ok, I think we've covered enough to get started now. We're going to implement a simple form of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Cumulative Sum\"), \" (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CUSUM\"), \") to detect significant changes in the mean of our input data.\"), mdx(\"p\", null, \"CUSUM is a technique for Sequential Analysis, which means it processes data one-at-a-time (sequentially) and it makes a decision about whether to continue. Remember our data stream:\"), mdx(\"p\", null, \"$$ X = \\\\left \", \"\\\\\", \"{ \\\\vec{x}\", \"_\", \"1, \\\\vec{x}\", \"_\", \"2, ... \\\\right \", \"\\\\\", \"}$$\"), mdx(\"p\", null, \"For each observation, we calculate a sum, and add it to the sum from the previous step. That is what makes it cumulative. The CUSUM procedure is:\"), mdx(\"p\", null, \"$$ g_0 = 0 $$\\n$$ g\", \"_\", \"{t+1} = max(0,g\", \"_\", \"t + x\", \"_\", \"t - \\\\omega\", \"_\", \"t)$$\"), mdx(\"p\", null, \"Where $x_t$ is our observation, $g\", \"_\", \"t$ is the cumulative sum at time $t$ and $\\\\omega\", \"_\", \"t$ is our target value at time $t$.\"), mdx(\"p\", null, \"We're also going to define a threshold, $\\\\lambda$ such that:\"), mdx(\"p\", null, \"$$H_1 \\\\text{ if } g\", \"_\", \"t > \\\\lambda \\\\text{ (else } H\", \"_\", \"0\\\\text{)}$$\"), mdx(\"p\", null, \"or in plain english,\"), mdx(\"p\", null, \"$$\\\\text{change if } g\", \"_\", \"t > \\\\lambda \\\\text{ (else continue)}$$\"), mdx(\"p\", null, \"That's still a bit abstract - how do we get $\\\\omega_t$, our target value? If we had all the data in advance, we could make this the mean. In the figure below, I've taken the mean and standard deviation of the first 25 data points as the basis for the CUSUM chart on the right.\\n\", mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"/content/images/2017/10/cusum.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"You can see that what we end up with is an accumulation of the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"differences\"), \" between the observed value and the target value. If this stacks up too high, we signal change. That's all there is to it. In this CUSUM chart, I used $5\\\\sigma$ as the threshold.\"), mdx(\"p\", null, \"In our request monitoring scenario, we're dealing with streaming data and we don't have anything in advance to calculate a mean. We're therefore going to approximate a mean as we go ($\\\\mu$) and make \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"that\"), \" the target value. We'll also add an extra parameter, $\\\\delta$, to specify the magnitude of change we find acceptable, ending up with:\"), mdx(\"p\", null, \"$$ g\", \"_\", \"{t+1} = max(0,g\", \"_\", \"t + x\", \"_\", \"t - \\\\mu - \\\\delta)$$\"), mdx(\"p\", null, \"Enough abstract stuff, let's write some code. For a start, we can define an interface for our change detection process.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"public interface ChangeDetector<T> {\\n\\n    /**\\n     * Provide the next item in the stream\\n     * @param observation the next item in the stream\\n     */\\n    void update(T observation);\\n\\n    /**\\n     * Did the detector signal change at the last item?\\n     * @return true, if it did.\\n     */\\n    boolean isChange();\\n\\n    /**\\n     * Has the detector seen enough items to detect change?\\n     * @return true, if it has.\\n     */\\n    boolean isReady();\\n\\n    /**\\n     * Reset the detector, wiping any memory component it retains.\\n     */\\n    void reset();\\n\\n}\\n\")), mdx(\"p\", null, \"And then putting our CUSUM detector together, we need to implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ChangeDetector<Double>\"), \", because we will take a single numeric value at each time step.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"public class CUSUMChangeDetector implements ChangeDetector<Double> {\\n\\n    private final static double DEFAULT_MAGNITUDE = 0.05;\\n    private final static double DEFAULT_THRESHOLD = 3;\\n    private final static long DEFAULT_READY_AFTER = 50;\\n\\n    private double cusumPrev = 0;\\n    private double cusum;\\n    private double magnitude;\\n    private double threshold;\\n    private double magnitudeMultiplier;\\n    private double thresholdMultiplier;\\n    private long   readyAfter;\\n\\n    private long   observationCount = 0;\\n    private double runningMean      = 0.0;\\n    private double runningVariance = 0.0;\\n\\n    private boolean change = false;\\n\\n    /**\\n     * Create a CUSUM detector\\n     * @param magnitudeMultiplier Magnitude of acceptable change in stddevs\\n     * @param thresholdMultiplier Threshold in stddevs\\n     * @param readyAfter Number of observations before allowing change to be signalled\\n     */\\n    public CUSUMChangeDetector(double magnitudeMultiplier, \\n                               double thresholdMultiplier, \\n                               long readyAfter) {\\n        this.magnitudeMultiplier = magnitudeMultiplier;\\n        this.thresholdMultiplier = thresholdMultiplier;\\n        this.readyAfter = readyAfter;\\n    }\\n\\n    public CUSUMChangeDetector() {\\n        this(DEFAULT_MAGNITUDE, DEFAULT_THRESHOLD, DEFAULT_READY_AFTER);\\n    }\\n\\n    @Override\\n    public void update(Double xi) {\\n        ++observationCount;\\n\\n        // Instead of providing the target mean as a parameter as \\n        // we would in an offline test, we calculate it as we go to \\n        // create a target of normality.\\n        double newMean = runningMean + (xi - runningMean) / observationCount;\\n        runningVariance += (xi - runningMean)*(xi - newMean);\\n        runningMean = newMean;\\n        double std = Math.sqrt(runningVariance);\\n\\n        magnitude = magnitudeMultiplier * std;\\n        threshold = thresholdMultiplier * std;\\n\\n        cusum = Math.max(0, cusumPrev +(xi - runningMean - magnitude));\\n\\n        if(isReady()) {\\n            this.change = cusum > threshold;\\n        }\\n\\n        cusumPrev = cusum;\\n    }\\n\\n    @Override\\n    public boolean isChange() {\\n        return change;\\n    }\\n\\n    @Override\\n    public boolean isReady() {\\n        return this.observationCount >= readyAfter;\\n    }\\n\\n    public void reset() {\\n        this.cusum = 0;\\n        this.cusumPrev = 0;\\n        this.runningMean = 0;\\n        this.observationCount = 0;\\n    }\\n\\n}\\n\")), mdx(\"p\", null, \"Now, using the power of spring boot, let's plug this into monitoring some request times. I'm not going to paste the code in here, but I've provided a full example in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/wfaithfull/cd4soft\"\n  }), \"this git repository\"), \".\"), mdx(\"p\", null, \"I have written the following test to assert that our detector can spot a change:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"\\n@Test\\npublic void changeDetectionTest() throws Exception {\\n    for(int i=0;i<200;i++) {\\n        mockMvc.perform(MockMvcRequestBuilders.get(\\\"/data\\\"))\\n                .andExpect(status().isOk());\\n        Assert.assertFalse(detector.isChange());\\n    }\\n\\n    int at = 0;\\n    boolean detected = false;\\n\\n    long delay = 0;\\n    for(int i=0;i<1000;i++) {\\n\\n        // Introduce abrupt change\\n        if(i % 100 == 0) {\\n            delay += 100;\\n            provider.setDelay(delay);\\n            log.info(\\\"Artificially slowed requests by {}ms\\\", delay);\\n        }\\n\\n        mockMvc.perform(MockMvcRequestBuilders.get(\\\"/data\\\"))\\n                .andExpect(status().isOk());\\n\\n        if(detector.isChange()) {\\n            at = i;\\n            detected = true;\\n            break;\\n        }\\n    }\\n\\n    Assert.assertTrue(detected);\\n    if(detected) {\\n        log.info(\\\"Detected change {} observations after change point\\\", at);\\n    }\\n}\\n\")), mdx(\"p\", null, \"If you go and run the example test, you will see something like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"2017-10-03 10:29:40.923  INFO 19836 --- [           main] me.faithfull.cd4soft.DataControllerTest  : Artificially slowed requests by 100ms\\n2017-10-03 10:29:42.146  INFO 19836 --- [           main] m.f.cd4soft.ChangeDetectionService       : CHANGE DETECTED! Time to send a midnight page to the sysadmin. Anomalous value: 102\\n2017-10-03 10:29:42.146  INFO 19836 --- [           main] me.faithfull.cd4soft.DataControllerTest  : Detected change 11 observations after change point\\nTests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.565 sec - in me.faithfull.cd4soft.DataControllerTest\\n\")), mdx(\"p\", null, \"And that's a basic and practical CUSUM.\"), mdx(\"h6\", null, \"Addendum\"), mdx(\"p\", null, \"I'm well aware that CUSUM may not be the best suited change detection approach for this particular problem, it is however a very simple approach applied to a very common practical problem. That is the tack I wish to take in this series because I feel it aids understanding.\"), mdx(\"p\", null, \"If you are modelling change in request times, you may wish to model them as a Poisson process, and investigate it's evolution.\"), mdx(\"h6\", null, \"Credits\"), mdx(\"p\", null, \"Thanks to Jon Snyder and Dan Silverglate, who pointed out a bug in the calculation of the variance within the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CUSUMChangeDetector\"), \" class.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"I've decided to force myself into the habit of blogging about my PhD topic, in the hope that people who find these posts have an easier time…","timeToRead":4,"banner":null}},"pageContext":{"slug":"/change-detection-for-software-engineers-part-i-introduction-and-cusum","formatString":"DD.MM.YYYY"}}}