{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/back-to-mvvm","result":{"data":{"post":{"__typename":"MdxPost","slug":"/back-to-mvvm","title":"Back to MVVM","date":"22.09.2016","tags":[{"name":"csharp","slug":"csharp"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Back to MVVM\",\n  \"date\": \"2016-09-22T00:00:00.000Z\",\n  \"slug\": \"/back-to-mvvm\",\n  \"tags\": [\"csharp\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The last WPF application that I worked on and saw through to the bitter end was the control software for the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.beerobotics.com/Products/RoboBlot/\"\n  }), \"RoboBlot\"), \". The last time I worked on it was in 2014, by which point I had migrated to working almost exclusively in Java, for a bunch of reasons.\"), mdx(\"p\", null, \"So, when I was asked at work to design and supervise the development of a basic WPF desktop application, I thought it was a nice opportunity to reflect on what I had done before. \"), mdx(\"h2\", null, \"What's the deal with MVVM anyway?\"), mdx(\"p\", null, \"The guy I'm supervising had made a Windows Forms application before, but had no experience with any of the MV-* patterns. MVC, MVP, MVVM, when you float through the sea of acronyms and competing frameworks, it can be extremely unhelpful and confusing.\"), mdx(\"p\", null, \"However, out of these patterns, MVVM has by far the most contradictory and conflicting explanations floating around on the internet. Does the model go in the viewmodel? The viewmodel in the view? Does the viewmodel have a reference to the view? Does the viewmodel implement INotifyPropertyChanged or the model? Or both? Should you duplicate the model properties in the viewmodel or just pass-through?\"), mdx(\"p\", null, \"If you go and search, you'll find a dozen blog posts and accepted stackoverflow answers all advocating different approaches to the above questions. Unfortunately, the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://msdn.microsoft.com/en-us/library/gg405484(v=pandp.40).aspx\"\n  }), \"\\\"official\\\"\"), \" \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://msdn.microsoft.com/en-gb/library/hh848246.aspx\"\n  }), \"documentation\"), \" is (compared to the documentation of the average Java library) tedious and often preferring snippets over complete examples, struggling to keep people's attention long enough. And even when people get the structure right, they find it less than clear how to integrate that with common patterns of application architecture, like \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Inversion of Control\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Dependency Injection\"), \". \"), mdx(\"p\", null, \"Another part of the confusion comes from the way that Windows Forms applications were built - in what is often colloquially called 'The codebehind'. You had your View, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Form.Designer.cs\"), \", and your codebehind, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Form.cs\"), \". The functionality associated with a button, for example, could be found in the often monolithic \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Form.cs\"), \". And this paradigm exists in WPF, with our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Window.xaml.cs\"), \" files. And whilst this has it's place in WPF, it allows people to build applications the Windows Forms way, in WPF. Which is just gross.\"), mdx(\"p\", null, \"But anyway, let's cut to the chase.\"), mdx(\"h2\", null, \"MVVM - The way I do it\"), mdx(\"p\", null, \"I don't use a framework like MVVMLight, Caliburn.Micro or Simple MVVM. I'm open to the idea of them and the features they provide but if you're trying to learn how MVVM works, I think it's more beneficial to go through the process yourself, because it's actually not that difficult.\"), mdx(\"p\", null, \"Each MVVM component could be thought of like a layer.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Layer\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"What you should have there\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"View\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Presentation Logic\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"ViewModel\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Actions\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Model\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Data\")))), mdx(\"p\", null, \"Our view just presents the model data in some meaningful way, and feeds user requests to the ViewModel, where they are processed. The ViewModel is responsible for handling these requests. That means that, if we were using \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Repository Pattern\"), \" for our data layer, we might inject repositories into the ViewModel, so that it can process persistence requests for it's attached model class. The model should JUST BE DATA (and INotifyPropertyChanged). Usually, if persistence is involved, the 'Model' is a particular database entity POCO. If this makes no sense to you, I have this pearl of wisdom:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If you're struggling to work out what your 'Model' is, then it's probably whatever you need to complete the 'Action' you want to do.\")), mdx(\"p\", null, \"It's easy if you're working on an application that persists a 'Customer' object for example - that's the model. What if you just want to interface with some underlying APIs, and don't have an actual thing that you want to manipulate? \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Don't worry about it\"), \". Just make the viewmodel, and the actions. Don't get so wound up in the pattern that you feel like you have to make a completely pointless 'Model' class. The View is the only thing using your ViewModel, and as long as it gets it's properties to bind to, it doesn't care. That's the beauty of MVVM - we don't have a circular dependency of responsibility like in MVC. Each layer is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"observed\"), \" by the one above.\"), mdx(\"p\", null, \"What about our composition? It's like this:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"View\"), \" has as \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ViewModel\"), \" which has a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Model\"), \".\"), mdx(\"p\", null, \"Simple, right? Not quite. We have a framework whose rules we have to play by, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"and\"), \" we also want to use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Inversion of Control\"), \" to componentize our application for when the requirements inevitably change. So, our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"MainWindow.xaml\"), \" is a View. That means it needs a reference to a ViewModel. But object creation is delegated to our IoC container - so how does this work in WPF? I'll talk about the scaffolding first.\"), mdx(\"p\", null, \"I've used \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://msdn.microsoft.com/en-gb/library/ff649614.aspx\"\n  }), \"Unity\"), \" as the IoC container this time around because it's bloody simple. I make a class to hold my dependency configuration, which I could call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DependencyConfiguration.cs\"), \" for sake of argument.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"public class DependencyConfiguration\\n{\\n    public static void Bootstrap()\\n    {\\n        IUnityContainer container = new UnityContainer();\\n        container.RegisterType<CustomerViewModel, CustomerViewModel>();\\n        // A bunch of other type registrations for other application components ...\\n        container.Resolve<MainWindow>().Show();\\n    }\\n}\\n\")), mdx(\"p\", null, \"and our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MainWindow.xaml.cs\"), \" looks like this, with constructor injection for the viewmodel.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"public partial class MainWindow : Window\\n{\\n    public MainWindow(CustomerViewModel viewModel)\\n    {\\n        this.DataContext = viewModel;\\n        InitializeComponent();\\n    }\\n}\\n\")), mdx(\"p\", null, \"Great - so we create our container, register the ViewModel there, and use the container to create \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MainWindow\"), \" and show it. We also had to setup \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App.xaml\"), \" to tell it not to create MainWindow itself by removing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StartupUri=MainWindow.xaml\"), \" from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Application\"), \" tag, and overriding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"OnStartup\"), \" in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App.xaml.cs\"), \" like so, to bootstrap our application.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"public partial class App : Application\\n{\\n    protected override void OnStartup(StartupEventArgs e)\\n    {\\n        base.OnStartup(e);\\n        DependencyConfiguration.Bootstrap();\\n    }\\n}\\n\")), mdx(\"p\", null, \"And thats our WPF application setup with IoC. Not too shabby.\"), mdx(\"p\", null, \"But what does \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CustomerViewModel.cs\"), \" look like, I hear you ask. Well, that's a good question. Let's talk about what we're doing first. Let's say we're making a simple CRUD application against a database, and we have a Customer entity which looks like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"public class Customer\\n{\\n    public long Id { get; set; }\\n    public string Name { get; set; }\\n    public bool IsEndUser { get; set; }\\n    public string CompanyName { get; set; }\\n    public string TelNo { get; set; }\\n}\\n\")), mdx(\"p\", null, \"Our persistence layer (which I'm not going to go into detail about) takes the form of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IRepository<T>\"), \", and handles the operations needed for creation, modification, retrieval, deletion, search, etc. So, our customer persistence object is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IRepository<Customer>\"), \", and the injection of this is handled by our IoC container. Our basic ViewModel will look something like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"public class BaseViewModel<T>\\n{\\n    IRepository<T> entityRepository;\\n    public T Model\\n    {\\n        get; set;\\n    }\\n\\n    public BaseViewModel(T model, IRepository<T> entityRepository)\\n    {\\n        this.Model = model;\\n        this.entityRepository = entityRepository;\\n    }\\n\\n    public ICommand Add\\n    {\\n        get\\n        {\\n            return new RelayCommand(x => entityRepository.Add(this.Model));\\n        }\\n    }\\n\\n    // Update, Delete, Search, etc...\\n}\\n\")), mdx(\"p\", null, \"With \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CustomerViewModel\"), \" a thin layer on top:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"public class CustomerViewModel : BaseViewModel<Customer>\\n{\\n    public CustomerViewModel(Customer model, IRepository<Customer> entityRepository) : base(model, entityRepository) { }\\n    public CustomerViewModel(IRepository<Customer> entityRepository) : base(new Customer(), entityRepository) { }\\n}\\n\")), mdx(\"p\", null, \"What's cool about \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CustomerViewModel\"), \"? Notice the two constructors - one that takes a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Customer\"), \" and one that doesn't. The purpose of this is that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IRepository<T>\"), \" is always going to have to come from the IoC container, whereas we might want to create a viewmodel by wrapping an existing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Customer\"), \" that we already have. If a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Customer\"), \" isn't provided, then the viewmodel is constructed with a fresh instance, ready for somebody to enter details and save, for example.\"), mdx(\"p\", null, \"Now that we have this, we can bind directly to the properties of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Model\"), \" from the view, for example, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{Binding Model.Name, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"), \". MVVM purists will tell you that this is unacceptable, but I am the laziest person I know, and I will not duplicate all the model properties into the viewmodel if I don't have a bloody compelling reason to.\"), mdx(\"p\", null, \"What's missing? Ah yes, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INotifyPropertyChanged\"), \". I want our model class to implement this, since we are binding directly to model properties. And for my money, the best solution to this bar none (remember I am very lazy) is \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/Fody/PropertyChanged\"\n  }), \"Fody.PropertyChanged\"), \". This will do some clever IL weaving to insert the tedious boilerplate for every model property. Add this NuGet package, and then, we can just do:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"[ImplementPropertyChanged]\\npublic class Customer  \\n{\\n    public long Id { get; set; }\\n    public string Name { get; set; }\\n    public bool IsEndUser { get; set; }\\n    public string CompanyName { get; set; }\\n    public string TelNo { get; set; }\\n}\\n\")), mdx(\"p\", null, \"And it will fire \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PropertyChanged\"), \" events for all the properties! What an incredibly elegant solution.\"), mdx(\"p\", null, \"And that's our basic MVVM implementation.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"The last WPF application that I worked on and saw through to the bitter end was the control software for the  RoboBlot . The last time I…","timeToRead":4,"banner":null}},"pageContext":{"slug":"/back-to-mvvm","formatString":"DD.MM.YYYY"}}}