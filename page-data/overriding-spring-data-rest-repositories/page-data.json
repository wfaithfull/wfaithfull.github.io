{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/overriding-spring-data-rest-repositories","result":{"data":{"post":{"__typename":"MdxPost","slug":"/overriding-spring-data-rest-repositories","title":"Overriding Spring Data REST repositories","date":"03.05.2017","tags":[{"name":"java","slug":"java"},{"name":"spring","slug":"spring"},{"name":"spring-data-rest","slug":"spring-data-rest"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Overriding Spring Data REST repositories\",\n  \"date\": \"2017-05-03T00:00:00.000Z\",\n  \"slug\": \"/overriding-spring-data-rest-repositories\",\n  \"tags\": [\"java\", \"spring\", \"spring-data-rest\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"We often use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spring-data-rest\"), \" to abstract away simple RESTful CRUD boilerplate, and it is very good at it. The problem comes in more complicated situations. Sometimes you need to step in and override one of the request handlers to do something slightly differently, or trigger an event. So, how do you reliably override request handlers for repositories which are exported with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@RepositoryRestResource\"), \"?\"), mdx(\"p\", null, \"The way to do so is poorly documented, and contains several caveats, which I will share from my experience. All we get in the documentation is this little snippet in section \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://docs.spring.io/spring-data/rest/docs/current/reference/html/#customizing-sdr.overriding-sdr-response-handlers\"\n  }), \"16.4\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"@RepositoryRestController\\npublic class ScannerController {\\n\\n    private final ScannerRepository repository;\\n\\n    @Autowired\\n    public ScannerController(ScannerRepository repo) { \\n        repository = repo;\\n    }\\n\\n    @RequestMapping(method = GET, value = \\\"/scanners/search/listProducers\\\") \\n    public @ResponseBody ResponseEntity<?> getProducers() {\\n        List<String> producers = repository.listProducers(); \\n\\n        //\\n        // do some intermediate processing, logging, etc. with the producers\\n        //\\n\\n        Resources<String> resources = new Resources<String>(producers); \\n\\n        resources.add(linkTo(methodOn(ScannerController.class).getProducers()).withSelfRel()); \\n\\n        // add other links as needed\\n\\n        return ResponseEntity.ok(resources); \\n    }\\n\\n}\\n\")), mdx(\"p\", null, \"What is wrong with this? Just one thing really. It adds a new method to the repository route, rather than overriding an existing one. Importantly, it doesn't mention that this approach will expressly not allow you to override existing handlers. So, how do we define a controller which takes precedence over a repository in the event that both sit on the same path?\"), mdx(\"h3\", null, \"From the top..\"), mdx(\"p\", null, \"Let's say we have an exported \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FooRepository\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"@RepositoryRestResource(exported=true, path=\\\"foos\\\")\\npublic interface FooRepository extends PagingAndSortingRepository<Foo,Long> {\\n\\n}\\n\")), mdx(\"p\", null, \"This exposes the basic CRUD:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"GET /foos\"), \" \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"POST /foos\"), \" \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"GET /foos/{id}\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"PUT /foos/{id}\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"POST /foos/{id}\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"PATCH /foos/{id}\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"DELETE /foos/{id}\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"HEAD /foos/{id}\"))), mdx(\"p\", null, \"Along with any association links rendered.\"), mdx(\"p\", null, \"Let's say we don't want to return ALL \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \"s on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GET /foos\"), \", but just the ones associated with our member.\"), mdx(\"h3\", null, \"How to do it\"), mdx(\"p\", null, \"We make an overriding controller.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"@BasePathAwareController\\npublic class FooController {\\n\\n    private final FooRepository fooRepository;\\n\\n    public FooController(final FooRepository fooRepository) {\\n        this.fooRepository = fooRepository;\\n    }\\n\\n    @RequestMapping(path=\\\"foos\\\", method=RequestMethod.GET, produces=\\\"application/hal+json\\\")\\n    public Resources getAllFooFiltered() {\\n        // Do your filtering and end up with a HATEOAS resources to return\\n    }\\n\\n}\\n\")), mdx(\"p\", null, \"That's it - a request to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/foos\"), \" will hit your controller now. Any other requests in the table above will still go to the exported repository handlers.\"), mdx(\"h3\", null, \"Gotchas / FAQ\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"It must be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@BasePathAwareController\"), \". \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@RepositoryRestController\"), \" will not override exported handlers, but you can use it to add handlers that aren't exported on the repository.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You must \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"NOT\"), \" have a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@RequestMapping\"), \" at the type level - it has to be at the method level as above.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"path\"), \" in your \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@RequestMapping(path=\\\"...\\\")\"), \" must \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"NOT\"), \" start with a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"/\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"OK\"), \": \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@RequestMapping(path=\\\"foos\\\")\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"NOT OK\"), \": \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@RequestMapping(path=\\\"/foos\\\")\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You cannot define a standalone mapping like \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"foos/count\"), \", because it clashes with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"foos/{id}\"), \". If you need to do this, you must override \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"foos/{id}\"), \" and decide what do do based on the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"{id}\"), \" path variable content. (e.g. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"if \\\"count\\\".equals(id) { ... }\"), \"). This is sort of an antipattern anyway.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You must \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"NOT\"), \" have any \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@PreAuthorize\"), \" annotations on the type or methods - this causes the class to be proxied and prevents the desired behaviour. If you need security rules, implement them in a service layer below the controller, or wait for Spring to fix. \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://jira.spring.io/browse/DATAREST-535?focusedCommentId=116225&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-116225\"\n  }), \"DATAREST-535\"))), mdx(\"h3\", null, \"Appendix - \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"@PreAuthorize\"), \" and controllers\"), mdx(\"p\", null, \"Attempting to apply \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@PreAuthorize\"), \" annotations on controller methods has been the cause of a lot of mysterious behaviour. A primary issue is the difference between CGLIB and JDK Dynamic proxies. JDK dynamic proxies are what spring uses by default if you have \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@EnableAspectJAutoProxy\"), \" - but they only work for classes that are interfaced. CGLIB proxies are more clever. You enable them with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@EnableAspectJAutoProxy(proxyTargetClass=true)\"), \", and they will actually create a dynamic subclass of the targeted type at runtime, thus allowing proxies of interface-less classes. However, this doesn't play nice with Spring Data REST, for reasons which I have not yet had time to investigate.\"), mdx(\"p\", null, \"If we apply some security annotations to the above overriding controller, and then try to hit one of the repository methods, what happens?\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"timestamp\\\": \\\"2017-05-04T08:23:46.090+0000\\\",\\n  \\\"status\\\": 405,\\n  \\\"error\\\": \\\"Method Not Allowed\\\",\\n  \\\"exception\\\": \\\"org.springframework.web.HttpRequestMethodNotSupportedException\\\",\\n  \\\"message\\\": \\\"Request method 'PATCH' not supported\\\",\\n  \\\"path\\\": \\\"/foos/1\\\"\\n}\\n\")), mdx(\"p\", null, \"So, that's now no good. We can offer our own routes, but can't hit the existing repository routes.\"), mdx(\"p\", null, \"Part of the reason this is particularly prevalent in controller classes is that they almost never implement interfaces, so their dynamic proxies (for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@PreAuthorize\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@Secured\"), \") will be CGLIB. The bulletproof solution at the moment is to do your fancy authorization annotations at the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"service layer\"), \". In fact, this is what is advocated in the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://docs.spring.io/spring-security/site/docs/4.2.2.RELEASE/reference/htmlsingle/#appendix-faq-method-security-in-web-context\"\n  }), \"spring security documentation\"), \" itself (important part is highlighted at the bottom).\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"44.2.16 I have added Spring Security\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"<global-method-security>\"), \" element to my application context but if I add security annotations to my Spring MVC controller beans (Struts actions etc.) then they don\\u2019t seem to have an effect.\"))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"In a Spring web application, the application context which holds the Spring MVC beans for the dispatcher servlet is often separate from the main application context. It is often defined in a file called myapp-servlet.xml, where \\\"myapp\\\" is the name assigned to the Spring DispatcherServlet in web.xml. An application can have multiple DispatcherServlets, each with its own isolated application context. The beans in these \\\"child\\\" contexts are not visible to the rest of the application. The\\\"parent\\\" application context is loaded by the ContextLoaderListener you define in your web.xml and is visible to all the child contexts. This parent context is usually where you define your security configuration, including the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<global-method-security>\"), \" element). As a result any security constraints applied to methods in these web beans will not be enforced, since the beans cannot be seen from the DispatcherServlet context. You need to either move the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<global-method-security>\"), \" declaration to the web context or moved the beans you want secured into the main application context. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Generally we would recommend applying method security at the service layer rather than on individual web controllers.\"))));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"We often use  spring-data-rest  to abstract away simple RESTful CRUD boilerplate, and it is very good at it. The problem comes in moreâ€¦","timeToRead":3,"banner":null}},"pageContext":{"slug":"/overriding-spring-data-rest-repositories","formatString":"DD.MM.YYYY"}}}