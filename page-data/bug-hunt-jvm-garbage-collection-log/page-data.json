{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/bug-hunt-jvm-garbage-collection-log","result":{"data":{"post":{"__typename":"MdxPost","slug":"/bug-hunt-jvm-garbage-collection-log","title":"Bug hunt: JVM garbage collection log","date":"12.08.2020","tags":[{"name":"bug-hunt","slug":"bug-hunt"},{"name":"java","slug":"java"},{"name":"ops","slug":"ops"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Bug hunt: JVM garbage collection log\",\n  \"date\": \"2020-08-12T00:00:00.000Z\",\n  \"slug\": \"/bug-hunt-jvm-garbage-collection-log\",\n  \"tags\": [\"bug-hunt\", \"java\", \"ops\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I spent some time in a platform engineering team earlier this year, and man was it fun. It sometimes feels like you're a digital detective, playing a high stakes game to track down the source of an issue.\\nNot all issues are super obscure, but this one was, and it was fascinating.\"), mdx(\"h4\", null, \"Setting the scene\"), mdx(\"p\", null, \"Our alerts informed us that a node was running out of disk space. This happens from time-to-time and is usually indicitive of\\na slightly under-zealous log rotation policy. Expectation was that we could clear some logs and tweak the rotation config.\"), mdx(\"p\", null, \"However, when we inspected the node, we found the root disk saturated with JVM crash dumps.\"), mdx(\"p\", null, \"This box used \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"logstash\"), \" for log shipping, and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"logrotate\"), \" for log truncation.\"), mdx(\"p\", null, \"We did find one odd thing - an application on this node was writing a JVM garbage collection log (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gc.log\"), \")\\nwhich was fairly large, but not suspiciously so. Upon inspecting this log file, we found that almost all\\nof it was unintelligable garbage that looked like this in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"less\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ less gc.log\\n^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@\\n^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@\\n^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@\\n\")), mdx(\"h4\", null, \"The problem\"), mdx(\"p\", null, \"For us, this was because \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"logrotate\"), \" and the JVM were both trying to write the file without a lock. JVM garbage collection logs appear to be special insofar as they're written directly from the JVM itself into the file. What happens is that the JVM keeps a handle to this file, and a location within it where it writes logs to. \"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"^@\"), \" is actually just a null byte in your file. You can see this if you run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hexdump -C your_gc.log\"), \". What causes these null bytes is the interesting part - \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"logrotate\"), \" truncating the file. \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ hexdump -C gc.log | head -3\\n00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\\n*\\n061ca010  00 00 00 00 00 00 00 32  30 32 30 2d 30 37 2d 30  |.......2020-07-0|\\n\")), mdx(\"p\", null, \"This only surfaced for us because we were using Logstash to monitor the GC log. Logstash was crashing with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"OutOfMemoryError\"), \" every time \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"logrotate\"), \" ran, and from inspecting heap dumps, we noticed that logstash was trying to ship a HUGE (600MB in JVM internal memory) log line that looked like:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"{ \\\"message\\\": \\\"\\\\u0000\\\\u0000\\\\u0000...\\n\")), mdx(\"p\", null, \"In this case, because logstash escapes the nulls to unicode (6 characters), and each character is represented as UTF-16 internally in the JVM, this means the on-heap encoding of this is a whopping factor of 12 larger than the null bytes on disk. So it takes a smaller log than you would expect to run out of memory.\"), mdx(\"p\", null, \"This lead us to find the nulls in the garbage collection log, and where they came from:\"), mdx(\"h5\", null, \"1. JVM happily writing logs\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"*-------------------------*\\n^                         ^\\nJVM's file start          JVM's current location\\n\")), mdx(\"h5\", null, \"2. logrotate has entered the game\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"                         **\\n\\\\________________________/\\n^                    |    ^\\nJVM's file start     |    JVM's current location\\n                     |\\n                     logrotate copies contents elsewhere and truncates file\\n                     to zero-length\\n\")), mdx(\"h5\", null, \"3. JVM keeps writing\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"*xxxxxxxxxxxxxxxxxxxxxxxxx-*\\n\\\\________________________/^^\\n^                    |    |JVM's current location\\nJVM's file start     |    JVM writes new log\\n                     |\\n                     File is now zero-length, but JVM still tries to write\\n                     to the end, so everything before it's pointer is \\n                     filled in with zeros\\n\")), mdx(\"h4\", null, \"TL;DR\"), mdx(\"p\", null, \"Don't use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"logrotate\"), \" to rotate JVM GC logs. It's behaviour does not play nicely with the way the JVM writes the GC log file. The JVM is capable of rotating it's own GC logs, using JVM flags:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-XX:+UseGCLogFileRotation\"), \" Enables GC log file rotation\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-XX:NumberOfGCLogFiles=5\"), \" Will tell the JVM to keep 5 rotated files\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-XX:GCLogFileSize=20M\"), \" Will tell the JVM to rotate when the file reaches 20M\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"I spent some time in a platform engineering team earlier this year, and man was it fun. It sometimes feels like you're a digital detectiveâ€¦","timeToRead":2,"banner":null}},"pageContext":{"slug":"/bug-hunt-jvm-garbage-collection-log","formatString":"DD.MM.YYYY"}}}